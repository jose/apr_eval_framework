diff --git a/src/main/java/org/springframework/data/util/ParameterizedTypeInformation.java b/src/main/java/org/springframework/data/util/ParameterizedTypeInformation.java
index 88a8a2fc4..798de32e0 100644
--- a/src/main/java/org/springframework/data/util/ParameterizedTypeInformation.java
+++ b/src/main/java/org/springframework/data/util/ParameterizedTypeInformation.java
@@ -52,35 +52,6 @@ class ParameterizedTypeInformation<T> extends ParentTypeAwareTypeInformation<T>
 		this.type = type;
 	}
 
-	/**
-	 * Resolves the type variables to be used. Uses the parent's type variable map but overwrites variables locally
-	 * declared.
-	 * 
-	 * @param type must not be {@literal null}.
-	 * @param resolvedType must not be {@literal null}.
-	 * @param parent must not be {@literal null}.
-	 * @return
-	 */
-	private static Map<TypeVariable<?>, Type> calculateTypeVariables(ParameterizedType type, Class<?> resolvedType,
-			TypeDiscoverer<?> parent) {
-
-		TypeVariable<?>[] typeParameters = resolvedType.getTypeParameters();
-		Type[] arguments = type.getActualTypeArguments();
-
-		Map<TypeVariable<?>, Type> localTypeVariables = new HashMap<TypeVariable<?>, Type>(parent.getTypeVariableMap());
-
-		for (int i = 0; i < typeParameters.length; i++) {
-
-			Type value = arguments[i];
-
-			if (!(value instanceof TypeVariable)) {
-				localTypeVariables.put(typeParameters[i], value);
-			}
-		}
-
-		return localTypeVariables;
-	}
-
 	/*
 	 * (non-Javadoc)
 	 * @see org.springframework.data.util.TypeDiscoverer#doGetMapValueType()
@@ -268,4 +239,47 @@ class ParameterizedTypeInformation<T> extends ParentTypeAwareTypeInformation<T>
 		this.resolved = resolved;
 		return resolved;
 	}
+
+	/**
+	 * Resolves the type variables to be used. Uses the parent's type variable map but overwrites variables locally
+	 * declared.
+	 * 
+	 * @param type must not be {@literal null}.
+	 * @param resolvedType must not be {@literal null}.
+	 * @param parent must not be {@literal null}.
+	 * @return will never be {@literal null}.
+	 */
+	private static Map<TypeVariable<?>, Type> calculateTypeVariables(ParameterizedType type, Class<?> resolvedType,
+			TypeDiscoverer<?> parent) {
+
+		TypeVariable<?>[] typeParameters = resolvedType.getTypeParameters();
+		Type[] arguments = type.getActualTypeArguments();
+
+		Map<TypeVariable<?>, Type> localTypeVariables = new HashMap<TypeVariable<?>, Type>(parent.getTypeVariableMap());
+
+		for (int i = 0; i < typeParameters.length; i++) {
+			localTypeVariables.put(typeParameters[i], flattenTypeVariable(arguments[i], localTypeVariables));
+		}
+
+		return localTypeVariables;
+	}
+
+	/**
+	 * Recursively resolves the type bound to the given {@link Type} in case it's a {@link TypeVariable} and there's an
+	 * entry in the given type variables.
+	 * 
+	 * @param source must not be {@literal null}.
+	 * @param variables must not be {@literal null}.
+	 * @return will never be {@literal null}.
+	 */
+	private static Type flattenTypeVariable(Type source, Map<TypeVariable<?>, Type> variables) {
+
+		if (!(source instanceof TypeVariable)) {
+			return source;
+		}
+
+		Type value = variables.get(source);
+
+		return value == null ? source : flattenTypeVariable(value, variables);
+	}
 }
diff --git a/src/main/java/org/springframework/data/util/TypeDiscoverer.java b/src/main/java/org/springframework/data/util/TypeDiscoverer.java
index f131ce2ab..b096ff842 100644
--- a/src/main/java/org/springframework/data/util/TypeDiscoverer.java
+++ b/src/main/java/org/springframework/data/util/TypeDiscoverer.java
@@ -134,7 +134,7 @@ class TypeDiscoverer<S> implements TypeInformation<S> {
 
 		if (fieldType instanceof TypeVariable) {
 			TypeVariable<?> variable = (TypeVariable<?>) fieldType;
-			return new TypeVariableTypeInformation(variable, type, this);
+			return new TypeVariableTypeInformation(variable, this);
 		}
 
 		if (fieldType instanceof GenericArrayType) {
diff --git a/src/main/java/org/springframework/data/util/TypeVariableTypeInformation.java b/src/main/java/org/springframework/data/util/TypeVariableTypeInformation.java
index 1314cc4e3..cc3db7a04 100644
--- a/src/main/java/org/springframework/data/util/TypeVariableTypeInformation.java
+++ b/src/main/java/org/springframework/data/util/TypeVariableTypeInformation.java
@@ -17,7 +17,6 @@ package org.springframework.data.util;
 
 import static org.springframework.util.ObjectUtils.*;
 
-import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 
@@ -32,61 +31,22 @@ import org.springframework.util.Assert;
 class TypeVariableTypeInformation<T> extends ParentTypeAwareTypeInformation<T> {
 
 	private final TypeVariable<?> variable;
-	private final Type owningType;
 
 	/**
-	 * Creates a bew {@link TypeVariableTypeInformation} for the given {@link TypeVariable} owning {@link Type} and parent
+	 * Creates a new {@link TypeVariableTypeInformation} for the given {@link TypeVariable} owning {@link Type} and parent
 	 * {@link TypeDiscoverer}.
 	 * 
 	 * @param variable must not be {@literal null}
 	 * @param owningType must not be {@literal null}
 	 * @param parent must not be {@literal null}.
 	 */
-	public TypeVariableTypeInformation(TypeVariable<?> variable, Type owningType, TypeDiscoverer<?> parent) {
+	public TypeVariableTypeInformation(TypeVariable<?> variable, TypeDiscoverer<?> parent) {
 
 		super(variable, parent);
 
 		Assert.notNull(variable, "TypeVariable must not be null!");
 
 		this.variable = variable;
-		this.owningType = owningType;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see org.springframework.data.util.TypeDiscoverer#getType()
-	 */
-	@Override
-	public Class<T> getType() {
-
-		int index = getIndex(variable);
-
-		if (owningType instanceof ParameterizedType && index != -1) {
-			Type fieldType = ((ParameterizedType) owningType).getActualTypeArguments()[index];
-			return resolveType(fieldType);
-		}
-
-		return resolveType(variable);
-	}
-
-	/**
-	 * Returns the index of the type parameter binding the given {@link TypeVariable}.
-	 * 
-	 * @param variable
-	 * @return
-	 */
-	private int getIndex(TypeVariable<?> variable) {
-
-		Class<?> rawType = resolveType(owningType);
-		TypeVariable<?>[] typeParameters = rawType.getTypeParameters();
-
-		for (int i = 0; i < typeParameters.length; i++) {
-			if (variable.equals(typeParameters[i])) {
-				return i;
-			}
-		}
-
-		return -1;
 	}
 
 	/*
diff --git a/src/test/java/org/springframework/data/util/ParameterizedTypeInformationUnitTests.java b/src/test/java/org/springframework/data/util/ParameterizedTypeInformationUnitTests.java
new file mode 100644
index 000000000..406b4d64f
--- /dev/null
+++ b/src/test/java/org/springframework/data/util/ParameterizedTypeInformationUnitTests.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright 2011-2017 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.util;
+
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+import static org.springframework.data.util.ClassTypeInformation.*;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.runners.MockitoJUnitRunner;
+import org.springframework.core.GenericTypeResolver;
+
+/**
+ * Unit tests for {@link ParameterizedTypeInformation}.
+ * 
+ * @author Oliver Gierke
+ * @author Mark Paluch
+ */
+@RunWith(MockitoJUnitRunner.class)
+public class ParameterizedTypeInformationUnitTests {
+
+	static final Map<TypeVariable<?>, Type> EMPTY_MAP = Collections.emptyMap();
+
+	@Mock ParameterizedType one;
+	Class<?> resolvedOne = GenericTypeResolver.resolveType(one, Collections.<TypeVariable, Type> emptyMap());
+
+	@Before
+	public void setUp() {
+		when(one.getActualTypeArguments()).thenReturn(new Type[0]);
+	}
+
+	@Test
+	public void considersTypeInformationsWithDifferingParentsNotEqual() {
+
+		TypeDiscoverer<String> stringParent = new TypeDiscoverer<String>(String.class, EMPTY_MAP);
+		TypeDiscoverer<Object> objectParent = new TypeDiscoverer<Object>(Object.class, EMPTY_MAP);
+
+		ParameterizedTypeInformation<Object> first = new ParameterizedTypeInformation<Object>(one, resolvedOne,
+				stringParent);
+		ParameterizedTypeInformation<Object> second = new ParameterizedTypeInformation<Object>(one, resolvedOne,
+				objectParent);
+
+		assertThat(first, is(not(second)));
+	}
+
+	@Test
+	public void considersTypeInformationsWithSameParentsNotEqual() {
+
+		TypeDiscoverer<String> stringParent = new TypeDiscoverer<String>(String.class, EMPTY_MAP);
+
+		ParameterizedTypeInformation<Object> first = new ParameterizedTypeInformation<Object>(one, resolvedOne,
+				stringParent);
+		ParameterizedTypeInformation<Object> second = new ParameterizedTypeInformation<Object>(one, resolvedOne,
+				stringParent);
+
+		assertTrue(first.equals(second));
+	}
+
+	@Test // DATACMNS-88
+	public void resolvesMapValueTypeCorrectly() {
+
+		TypeInformation<Foo> type = ClassTypeInformation.from(Foo.class);
+		TypeInformation<?> propertyType = type.getProperty("param");
+		assertThat(propertyType.getProperty("value").getType(), is(typeCompatibleWith(String.class)));
+		assertThat(propertyType.getMapValueType().getType(), is(typeCompatibleWith(String.class)));
+
+		propertyType = type.getProperty("param2");
+		assertThat(propertyType.getProperty("value").getType(), is(typeCompatibleWith(String.class)));
+		assertThat(propertyType.getMapValueType().getType(), is(typeCompatibleWith(Locale.class)));
+	}
+
+	@Test // DATACMNS-446
+	public void createsToStringRepresentation() {
+
+		assertThat(from(Foo.class).getProperty("param").toString(),
+				is("org.springframework.data.util.ParameterizedTypeInformationUnitTests$Localized<java.lang.String>"));
+	}
+
+	@Test // DATACMNS-485
+	@SuppressWarnings("rawtypes")
+	public void hashCodeShouldBeConsistentWithEqualsForResolvedTypes() {
+
+		TypeInformation first = from(First.class).getProperty("property");
+		TypeInformation second = from(Second.class).getProperty("property");
+
+		assertThat(first, is(second));
+		assertThat(first.hashCode(), is(second.hashCode()));
+	}
+
+	@Test // DATACMNS-485
+	@SuppressWarnings("rawtypes")
+	public void getActualTypeShouldNotUnwrapParameterizedTypes() {
+
+		TypeInformation type = from(First.class).getProperty("property");
+		assertThat(type.getActualType(), is(type));
+	}
+
+	@Test // DATACMNS-697
+	public void usesLocalGenericInformationOfFields() {
+
+		TypeInformation<NormalizedProfile> information = ClassTypeInformation.from(NormalizedProfile.class);
+		TypeInformation<?> valueType = information.getProperty("education2.data").getComponentType();
+		assertThat(valueType.getProperty("value").getType(), is(typeCompatibleWith(Education.class)));
+	}
+
+	@Test // DATACMNS-899
+	public void returnsNullMapValueTypeForNonMapProperties() {
+
+		TypeInformation<?> valueType = ClassTypeInformation.from(Bar.class).getProperty("param");
+		TypeInformation<?> mapValueType = valueType.getMapValueType();
+
+		assertThat(valueType, instanceOf(ParameterizedTypeInformation.class));
+		assertThat(mapValueType, is(nullValue()));
+	}
+
+	@Test // DATACMNS-1135
+	public void prefersLocalGenericsDeclarationOverParentBound() {
+
+		ClassTypeInformation<Candidate> candidate = ClassTypeInformation.from(Candidate.class);
+
+		TypeInformation<?> componentType = candidate.getProperty("experiences.values").getComponentType();
+		componentType = componentType.getProperty("responsibilities.values").getComponentType();
+
+		assertThat(componentType.getType(), is(typeCompatibleWith(Responsibility.class)));
+	}
+
+	@Test // DATACMNS-1196
+	public void detectsNestedGenerics() {
+
+		TypeInformation<?> myList = ClassTypeInformation.from(EnumGeneric.class).getProperty("inner.myList");
+
+		assertThat(myList.getComponentType().getType(), is(typeCompatibleWith(MyEnum.class)));
+	}
+
+	@SuppressWarnings("serial")
+	class Localized<S> extends HashMap<Locale, S> {
+		S value;
+	}
+
+	@SuppressWarnings("serial")
+	class Localized2<S> extends HashMap<S, Locale> {
+		S value;
+	}
+
+	class Foo {
+		Localized<String> param;
+		Localized2<String> param2;
+	}
+
+	class Bar {
+		List<String> param;
+	}
+
+	class Parameterized<T> {
+		T property;
+	}
+
+	class First {
+		Parameterized<String> property;
+	}
+
+	class Second {
+		Parameterized<String> property;
+	}
+
+	// see DATACMNS-697
+
+	class NormalizedProfile {
+
+		ListField<Education> education2;
+	}
+
+	class ListField<L> {
+		List<Value<L>> data;
+	}
+
+	class Value<T> {
+		T value;
+	}
+
+	class Education {}
+
+	// DATACMNS-1135
+
+	abstract class CandidateInfo {}
+
+	class Responsibility extends CandidateInfo {}
+
+	class Experience extends CandidateInfo {
+		CandidateInfoContainer<Responsibility> responsibilities;
+	}
+
+	class CandidateInfoContainer<E extends CandidateInfo> {
+		List<E> values;
+	}
+
+	class Candidate {
+		CandidateInfoContainer<Experience> experiences;
+	}
+
+	// FOO
+
+	static abstract class Generic<T> {
+
+		Inner<T> inner;
+
+		static class Inner<T> {
+			List<T> myList;
+		}
+	}
+
+	static class EnumGeneric extends Generic<MyEnum> {}
+
+	public enum MyEnum {
+		E1, E2
+	}
+}
