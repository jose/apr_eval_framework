diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java
index dbba25d3e..a3af8cc9a 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java
@@ -952,7 +952,9 @@ public class MapSerializer
         }
         // [databind#1411]: TreeMap does not like null key... (although note that
         //   check above should prevent this code from being called in that case)
-        if (input.containsKey(null)) {
+        // [databind#153]: but, apparently, some custom Maps do manage hit this
+        //   problem.
+        if (_hasNullKey(input)) {
             TreeMap<Object,Object> result = new TreeMap<Object,Object>();
             for (Map.Entry<?,?> entry : input.entrySet()) {
                 Object key = entry.getKey();
@@ -967,6 +969,22 @@ public class MapSerializer
         return new TreeMap<Object,Object>(input);
     }
 
+    /**
+     * @since 2.8.7
+     */
+    protected boolean _hasNullKey(Map<?,?> input) {
+        // 19-Feb-2017, tatu: As per [databind#1513] there are many cases where `null`
+        //   keys are not allowed, and even attempt to check for presence can cause
+        //   problems. Without resorting to external sorting (and internal API change),
+        //   or custom sortable Map implementation (more code) we can try black- or
+        //   white-listing (that is; either skip known problem cases; or only apply for
+        //   known good cases).
+        //   While my first instinct was to do black-listing (remove Hashtable and ConcurrentHashMap),
+        //   all in all it is probably better to just white list `HashMap` (and its sub-classes).
+        
+        return (input instanceof HashMap) && input.containsKey(null);
+    }
+    
     protected void _writeNullKeyedEntry(JsonGenerator gen, SerializerProvider provider,
             Object suppressableValue, Object value) throws IOException
     {
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java
index bbda642cf..a220237ed 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java
@@ -287,14 +287,27 @@ public class TestMapSerialization extends BaseMapTest
     }
 
     // [databind#1513]
-    public void testConcurrentSkipListMap() throws Exception
+    public void testConcurrentMaps() throws Exception
     {
+        final ObjectWriter w = MAPPER.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS);
+
         Map<String,String> input = new ConcurrentSkipListMap<String,String>();
+        input.put("x", "y");
         input.put("a", "b");
+        String json = w.writeValueAsString(input);
+        assertEquals(aposToQuotes("{'a':'b','x':'y'}"), json);
+
+        input = new ConcurrentHashMap<String,String>();
         input.put("x", "y");
-        String json = MAPPER
-                .writer().with(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)
-                .writeValueAsString(input);
+        input.put("a", "b");
+        json = w.writeValueAsString(input);
+        assertEquals(aposToQuotes("{'a':'b','x':'y'}"), json);
+
+        // One more: while not technically concurrent map at all, exhibits same issue
+        input = new Hashtable<String,String>();
+        input.put("x", "y");
+        input.put("a", "b");
+        json = w.writeValueAsString(input);
         assertEquals(aposToQuotes("{'a':'b','x':'y'}"), json);
     }
 }
