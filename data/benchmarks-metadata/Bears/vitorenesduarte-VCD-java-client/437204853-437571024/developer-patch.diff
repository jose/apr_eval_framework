diff --git a/src/main/java/org/imdea/vcd/queue/box/CommittedQueueBox.java b/src/main/java/org/imdea/vcd/queue/box/CommittedQueueBox.java
index 67a647e98..35af9af64 100644
--- a/src/main/java/org/imdea/vcd/queue/box/CommittedQueueBox.java
+++ b/src/main/java/org/imdea/vcd/queue/box/CommittedQueueBox.java
@@ -35,7 +35,11 @@ public class CommittedQueueBox implements QueueBox<CommittedQueueBox> {
 
     public CommittedQueueBox(CommittedQueueBox commitDepBox) {
         this.dots = new Dots(commitDepBox.dots);
-        this.dep = new Clock<>(commitDepBox.dep);
+        if (commitDepBox.dep != null) {
+            this.dep = new Clock<>(commitDepBox.dep);
+        } else {
+            this.dep = null;
+        }
         this.messageMap = new MessageMap(commitDepBox.messageMap);
     }
 
diff --git a/src/test/java/org/imdea/vcd/Generator.java b/src/test/java/org/imdea/vcd/Generator.java
index c0579e6da..a507dc49e 100644
--- a/src/test/java/org/imdea/vcd/Generator.java
+++ b/src/test/java/org/imdea/vcd/Generator.java
@@ -24,9 +24,18 @@ public class Generator {
 
     public static Message message() {
         Integer conflicts = RANDOM().nextInt(100);
+        ByteString key = hash(randomByteString(KEY_SIZE), conflicts);
+        return message(key);
+    }
+
+    public static Message message(String key) {
+        return message(bs(key.getBytes()));
+    }
+
+    public static Message message(ByteString key) {
         ByteString data = randomByteString(RANDOM().nextInt(100));
         return Message.newBuilder()
-                .addHashes(hash(randomByteString(KEY_SIZE), conflicts))
+                .addHashes(key)
                 .setData(data)
                 .build();
     }
diff --git a/src/test/java/org/imdea/vcd/queue/ConfQueueTest.java b/src/test/java/org/imdea/vcd/queue/ConfQueueTest.java
index e4d06e165..79ed87f13 100644
--- a/src/test/java/org/imdea/vcd/queue/ConfQueueTest.java
+++ b/src/test/java/org/imdea/vcd/queue/ConfQueueTest.java
@@ -6,7 +6,6 @@ import org.imdea.vcd.Generator;
 import org.imdea.vcd.pb.Proto.Message;
 import org.imdea.vcd.queue.clock.Clock;
 import org.imdea.vcd.queue.clock.Dot;
-import org.imdea.vcd.queue.clock.ExceptionSet;
 import org.imdea.vcd.queue.clock.MaxInt;
 import org.junit.Test;
 
@@ -17,6 +16,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import org.imdea.vcd.queue.clock.Dots;
+import org.imdea.vcd.queue.clock.ExceptionSet;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -48,11 +48,11 @@ public class ConfQueueTest {
     public void testFailures() {
         for (int i = 0; i < ITERATIONS; i++) {
             Integer nodeNumber = 2;
-            Map<Dot, Clock<MaxInt>> dotToConf = Generator.dotToConf(nodeNumber);
-            while (dotToConf.isEmpty()) {
+            Map<Dot, Clock<MaxInt>> dotToConf;
+            do {
                 // make sure we don't generate an empty map
                 dotToConf = Generator.dotToConf(nodeNumber);
-            }
+            } while (dotToConf.isEmpty());
 
             List<QueueAddArgs> argsList = new ArrayList<>();
             for (Map.Entry<Dot, Clock<MaxInt>> e : dotToConf.entrySet()) {
@@ -63,7 +63,7 @@ public class ConfQueueTest {
 
             // create the commit clock after failure
             QueueAddArgs committedArgs = argsList.remove(0);
-            Clock<ExceptionSet> committed = Clock.eclock(committedArgs.getConf());
+            Clock<MaxInt> committed = Clock.eclock(committedArgs.getConf());
 
             checkTerminationRandomShuffles(committed, argsList);
         }
@@ -73,70 +73,52 @@ public class ConfQueueTest {
     public void testAdd1() {
         Integer nodeNumber = 2;
 
-        // {{0, 2}, [{0, 2}, {1, 2}]}
+        // {0, 2}, [2, 2]
         Dot dotA = new Dot(0, 2L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(2L, 1L));
-        mapA.put(1, new ExceptionSet(2L, 1L));
+        Clock<MaxInt> confA = vclock(2L, 2L);
 
-        // {{0, 1}, [{0, 1}, {0, 2}, {0, 3}, {1, 2}]}
+        // {0, 1}, [3, 2]
         Dot dotB = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet(3L));
-        mapB.put(1, new ExceptionSet(2L, 1L));
+        Clock<MaxInt> confB = vclock(3L, 2L);
 
-        // {{0, 5}, [{0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {1, 1}, {1, 2}]}
+        // {0, 5}, [6, 2]
         Dot dotC = new Dot(0, 5L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(6L));
-        mapC.put(1, new ExceptionSet(2L));
+        Clock<MaxInt> confC = vclock(6L, 2L);
 
-        // {{0, 6}, [{0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {1, 1}, {1, 2}, {1, 3}]}
+        // {0, 6}, [6, 3]
         Dot dotD = new Dot(0, 6L);
-        HashMap<Integer, ExceptionSet> mapD = new HashMap<>();
-        mapD.put(0, new ExceptionSet(6L));
-        mapD.put(1, new ExceptionSet(3L));
+        Clock<MaxInt> confD = vclock(6L, 3L);
 
-        // {{0, 3}, [{0, 1}, {0, 2}, {0, 3}, {1, 1}, {1, 2}, {1, 3}]}
+        // {0, 3}, [3, 3]
         Dot dotE = new Dot(0, 3L);
-        HashMap<Integer, ExceptionSet> mapE = new HashMap<>();
-        mapE.put(0, new ExceptionSet(3L));
-        mapE.put(1, new ExceptionSet(3L));
+        Clock<MaxInt> confE = vclock(3L, 3L);
 
-        // {{1, 2}, [{1, 2}]}
+        // {1, 2}, [0, 2]
         Dot dotF = new Dot(1, 2L);
-        HashMap<Integer, ExceptionSet> mapF = new HashMap<>();
-        mapF.put(0, new ExceptionSet(0L));
-        mapF.put(1, new ExceptionSet(2L, 1L));
+        Clock<MaxInt> confF = vclock(0L, 2L);
 
-        // {{1, 1}, [{0, 1}, {0, 2}, {0, 3}, {0, 4}, {1, 1}, {1, 2}, {1, 3}]}
+        // {1, 1}, [4, 3]
         Dot dotG = new Dot(1, 1L);
-        HashMap<Integer, ExceptionSet> mapG = new HashMap<>();
-        mapG.put(0, new ExceptionSet(4L));
-        mapG.put(1, new ExceptionSet(3L));
+        Clock<MaxInt> confG = vclock(4L, 3L);
 
-        // {{0, 4}, [{0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 6}, {1, 1}, {1, 2}]}
+        // {0, 4}, [6, 2]
         Dot dotH = new Dot(0, 4L);
-        HashMap<Integer, ExceptionSet> mapH = new HashMap<>();
-        mapH.put(0, new ExceptionSet(6L, 5L));
-        mapH.put(1, new ExceptionSet(2L));
+        Clock<MaxInt> confH = vclock(6L, 2L);
 
-        // {{1, 3}, [{0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {1, 1}, {1, 2}, {1, 3}]}
+        // {1, 3}, [6, 3]
         Dot dotI = new Dot(1, 3L);
-        HashMap<Integer, ExceptionSet> mapI = new HashMap<>();
-        mapI.put(0, new ExceptionSet(6L));
-        mapI.put(1, new ExceptionSet(3L));
+        Clock<MaxInt> confI = vclock(6L, 3L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
-        argsList.add(args(dotD, mapD));
-        argsList.add(args(dotE, mapE));
-        argsList.add(args(dotF, mapF));
-        argsList.add(args(dotG, mapG));
-        argsList.add(args(dotH, mapH));
-        argsList.add(args(dotI, mapI));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
+        argsList.add(args(dotD, confD));
+        argsList.add(args(dotE, confE));
+        argsList.add(args(dotF, confF));
+        argsList.add(args(dotG, confG));
+        argsList.add(args(dotH, confH));
+        argsList.add(args(dotI, confI));
 
         checkTerminationRandomShuffles(nodeNumber, argsList);
     }
@@ -145,56 +127,42 @@ public class ConfQueueTest {
     public void testAdd2() {
         Integer nodeNumber = 2;
 
-        // {{1, 4}, [{0, 2}, {0, 3}, {1, 1}, {1, 2}, {1, 3}, {1, 4}]}
+        // {1, 4}, [3, 4]
         Dot dotA = new Dot(1, 4L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(3L, 1L));
-        mapA.put(1, new ExceptionSet(4L));
+        Clock<MaxInt> confA = vclock(3L, 4L);
 
-        // {{1, 3}, [{1, 2}, {1, 3}]}
+        // {1, 3}, [0, 3]
         Dot dotB = new Dot(1, 3L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet());
-        mapB.put(1, new ExceptionSet(3L, 1L));
+        Clock<MaxInt> confB = vclock(0L, 3L);
 
-        // {{0, 3}, [{0, 3}, {1, 2}, {1, 3}]}
+        // {0, 3}, [3, 3]
         Dot dotC = new Dot(0, 3L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(3L, 1L, 2L));
-        mapC.put(1, new ExceptionSet(3L, 1L));
+        Clock<MaxInt> confC = vclock(3L, 3L);
 
-        // {{0, 1}, [{0, 1}, {0, 2}, {0, 3}, {1, 1}, {1, 2}, {1, 3}, {1, 4}]}
+        // {0, 1}, [3, 4]
         Dot dotD = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapD = new HashMap<>();
-        mapD.put(0, new ExceptionSet(3L));
-        mapD.put(1, new ExceptionSet(4L));
+        Clock<MaxInt> confD = vclock(3L, 4L);
 
-        // {{1, 2}, [{1, 2}]}
+        // {1, 2}, [0, 2]
         Dot dotE = new Dot(1, 2L);
-        HashMap<Integer, ExceptionSet> mapE = new HashMap<>();
-        mapE.put(0, new ExceptionSet());
-        mapE.put(1, new ExceptionSet(2L, 1L));
+        Clock<MaxInt> confE = vclock(0L, 2L);
 
-        // {{0, 2}, [{0, 1}, {0, 2}, {0, 3}, {1, 1}, {1, 2}, {1, 3}]}
+        // {0, 2}, [3, 3]
         Dot dotF = new Dot(0, 2L);
-        HashMap<Integer, ExceptionSet> mapF = new HashMap<>();
-        mapF.put(0, new ExceptionSet(3L));
-        mapF.put(1, new ExceptionSet(3L));
+        Clock<MaxInt> confF = vclock(3L, 3L);
 
-        // {{1, 1}, [{0, 1}, {0, 3}, {1, 1}, {1, 2}, {1, 3}]}
+        // {1, 1}, [3, 3]
         Dot dotG = new Dot(1, 1L);
-        HashMap<Integer, ExceptionSet> mapG = new HashMap<>();
-        mapG.put(0, new ExceptionSet(3L, 2L));
-        mapG.put(1, new ExceptionSet(3L));
+        Clock<MaxInt> confG = vclock(3L, 3L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
-        argsList.add(args(dotD, mapD));
-        argsList.add(args(dotE, mapE));
-        argsList.add(args(dotF, mapF));
-        argsList.add(args(dotG, mapG));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
+        argsList.add(args(dotD, confD));
+        argsList.add(args(dotE, confE));
+        argsList.add(args(dotF, confF));
+        argsList.add(args(dotG, confG));
 
         checkTerminationRandomShuffles(nodeNumber, argsList);
     }
@@ -203,47 +171,32 @@ public class ConfQueueTest {
     public void testAdd3() {
         Integer nodeNumber = 3;
 
-        // {{2, 2}, [{0, 1}, {2, 2}]}
+        // {{2, 2}, [1, 0, 2]
         Dot dotA = new Dot(2, 2L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(1L));
-        mapA.put(1, new ExceptionSet());
-        mapA.put(2, new ExceptionSet(2L, 1L));
+        Clock<MaxInt> confA = vclock(1L, 0L, 2L);
 
-        // {{2, 3}, [{0, 1}, {1, 1}, {2, 2}, {2, 3}]}
+        // {{2, 3}, [1, 1, 3]
         Dot dotB = new Dot(2, 3L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet(1L));
-        mapB.put(1, new ExceptionSet(1L));
-        mapB.put(2, new ExceptionSet(3L, 1L));
+        Clock<MaxInt> confB = vclock(1L, 1L, 3L);
 
-        // {{2, 1}, [{0, 1}, {1, 1}, {2, 1}, {2, 2}, {2, 3}]}
+        // {{2, 1}, [1, 1, 3]
         Dot dotC = new Dot(2, 1L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(1L));
-        mapC.put(1, new ExceptionSet(1L));
-        mapC.put(2, new ExceptionSet(3L));
+        Clock<MaxInt> confC = vclock(1L, 1L, 3L);
 
-        // {{0, 1}, [{0, 1}]}
+        // {{0, 1}, [1, 0, 0]
         Dot dotD = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapD = new HashMap<>();
-        mapD.put(0, new ExceptionSet(1L));
-        mapD.put(1, new ExceptionSet());
-        mapD.put(2, new ExceptionSet());
+        Clock<MaxInt> confD = vclock(1L , 0L, 0L);
 
-        // {{1, 1}, [{0, 1}, {1, 1}, {2, 2}]}
+        // {{1, 1}, [1, 1, 2]
         Dot dotE = new Dot(1, 1L);
-        HashMap<Integer, ExceptionSet> mapE = new HashMap<>();
-        mapE.put(0, new ExceptionSet(1L));
-        mapE.put(1, new ExceptionSet(1L));
-        mapE.put(2, new ExceptionSet(2L, 1L));
+        Clock<MaxInt> confE = vclock(1L, 1L, 2L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
-        argsList.add(args(dotD, mapD));
-        argsList.add(args(dotE, mapE));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
+        argsList.add(args(dotD, confD));
+        argsList.add(args(dotE, confE));
 
         checkTerminationRandomShuffles(nodeNumber, argsList);
     }
@@ -252,43 +205,37 @@ public class ConfQueueTest {
     public void testAdd4() {
         Integer nodeNumber = 1;
 
-        // {{0, 5}, [{0, 5}]}
+        // {{0, 5}, [5]
         Dot dotA = new Dot(0, 5L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(5L, 1L, 2L, 3L, 4L));
+        Clock<MaxInt> confA = vclock(5L);
 
-        // {{0, 4}, [{0, 1}, {0, 3}, {0, 4}, {0, 5}, {0, 6}]}
+        // {{0, 4}, [6]
         Dot dotB = new Dot(0, 4L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet(6L, 2L));
+        Clock<MaxInt> confB = vclock(6L);
 
-        // {{0, 1}, [{0, 1}, {0, 3}, {0, 5}]}
+        // {{0, 1}, [5]
         Dot dotC = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(5L, 2L, 4L));
+        Clock<MaxInt> confC = vclock(5L);
 
-        // {{0, 2}, [{0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}]}
+        // {{0, 2}, [6]
         Dot dotD = new Dot(0, 2L);
-        HashMap<Integer, ExceptionSet> mapD = new HashMap<>();
-        mapD.put(0, new ExceptionSet(6L));
+        Clock<MaxInt> confD = vclock(6L);
 
-        // {{0, 3}, [{0, 3}, {0, 5}]}
+        // {{0, 3}, [5]
         Dot dotE = new Dot(0, 3L);
-        HashMap<Integer, ExceptionSet> mapE = new HashMap<>();
-        mapE.put(0, new ExceptionSet(5L, 1L, 2L, 4L));
+        Clock<MaxInt> confE = vclock(5L);
 
-        // {{0, 6}, [{0, 1}, {0, 3}, {0, 5}, {0, 6}]}
+        // {{0, 6}, [6]
         Dot dotF = new Dot(0, 6L);
-        HashMap<Integer, ExceptionSet> mapF = new HashMap<>();
-        mapF.put(0, new ExceptionSet(6L, 2L, 4L));
+        Clock<MaxInt> confF = vclock(6L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
-        argsList.add(args(dotD, mapD));
-        argsList.add(args(dotE, mapE));
-        argsList.add(args(dotF, mapF));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
+        argsList.add(args(dotD, confD));
+        argsList.add(args(dotE, confE));
+        argsList.add(args(dotF, confF));
 
         checkTerminationRandomShuffles(nodeNumber, argsList);
     }
@@ -297,28 +244,22 @@ public class ConfQueueTest {
     public void testAdd5() {
         Integer nodeNumber = 2;
 
-        // {{0, 1}, [{0, 1}, {1, 1}]}
+        // {{0, 1}, [1, 1]
         Dot dotA = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(1L));
-        mapA.put(1, new ExceptionSet(1L));
+        Clock<MaxInt> confA = vclock(1L, 1L);
 
-        // {{0, 2}, [{0, 2}, {1, 0}]}
+        // {{0, 2}, [2, 0]
         Dot dotB = new Dot(0, 2L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet(2L));
-        mapB.put(1, new ExceptionSet());
+        Clock<MaxInt> confB = vclock(2L, 0L);
 
-        // {{1, 1}, [{0, 1}, {1, 1}]}
+        // {{1, 1}, [1, 1]
         Dot dotC = new Dot(1, 1L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(1L));
-        mapC.put(1, new ExceptionSet(1L));
+        Clock<MaxInt> confC = vclock(1L, 1L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
 
         checkTerminationRandomShuffles(nodeNumber, argsList);
     }
@@ -327,84 +268,62 @@ public class ConfQueueTest {
     public void testAdd6() {
         Integer nodeNumber = 2;
 
-        // {{0, 1}, [{0, 1}]}
+        // {{0, 1}, [1, 0]
         Dot dotA = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(1L));
-        mapA.put(1, new ExceptionSet());
+        Clock<MaxInt> confA = vclock(1L, 0L);
 
-        // {{0, 2}, [{0, 4}, {1, 1}]}
+        // {{0, 2}, [4, 1]
         Dot dotB = new Dot(0, 2L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet(4L));
-        mapB.put(1, new ExceptionSet(1L));
+        Clock<MaxInt> confB = vclock(4L, 1L);
 
-        // {{0, 3}, [{0, 3}]}
+        // {{0, 3}, [3, 0]
         Dot dotC = new Dot(0, 3L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(3L));
-        mapC.put(1, new ExceptionSet());
+        Clock<MaxInt> confC = vclock(3L, 0L);
 
-        // {{0, 4}, [{0, 4}]}
+        // {{0, 4}, [4, 0]
         Dot dotD = new Dot(0, 4L);
-        HashMap<Integer, ExceptionSet> mapD = new HashMap<>();
-        mapD.put(0, new ExceptionSet(4L));
-        mapD.put(1, new ExceptionSet());
+        Clock<MaxInt> confD = vclock(4L, 0L);
 
-        // {{1, 1}, [{1, 1}]}
+        // {{1, 1}, [0, 1]
         Dot dotE = new Dot(1, 1L);
-        HashMap<Integer, ExceptionSet> mapE = new HashMap<>();
-        mapE.put(0, new ExceptionSet());
-        mapE.put(1, new ExceptionSet(1L));
+        Clock<MaxInt> confE = vclock(0L, 1L);
 
-        // {{1, 2}, [{0,3}, {1, 2}]}
+        // {{1, 2}, [3, 2]
         Dot dotF = new Dot(1, 2L);
-        HashMap<Integer, ExceptionSet> mapF = new HashMap<>();
-        mapF.put(0, new ExceptionSet(3L));
-        mapF.put(1, new ExceptionSet(2L));
+        Clock<MaxInt> confF = vclock(3L, 2L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
-        argsList.add(args(dotD, mapD));
-        argsList.add(args(dotE, mapE));
-        argsList.add(args(dotF, mapF));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
+        argsList.add(args(dotD, confD));
+        argsList.add(args(dotE, confE));
+        argsList.add(args(dotF, confF));
 
         checkTerminationRandomShuffles(nodeNumber, argsList);
     }
 
     @Test
     public void testFailure1() {
-        Integer nodeNumber = 2;
-
         // {0, 1} [4, 0]
         Dot dotA = new Dot(0, 1L);
-        HashMap<Integer, ExceptionSet> mapA = new HashMap<>();
-        mapA.put(0, new ExceptionSet(4L));
-        mapA.put(1, new ExceptionSet());
+        Clock<MaxInt> confA = vclock(4L, 0L);
 
         // {0, 3} [3, 0]
         Dot dotB = new Dot(0, 3L);
-        HashMap<Integer, ExceptionSet> mapB = new HashMap<>();
-        mapB.put(0, new ExceptionSet(3L));
-        mapB.put(1, new ExceptionSet());
+        Clock<MaxInt> confB = vclock(3L, 0L);
 
         // {0, 4} [4, 0]
         Dot dotC = new Dot(0, 4L);
-        HashMap<Integer, ExceptionSet> mapC = new HashMap<>();
-        mapC.put(0, new ExceptionSet(4L));
-        mapC.put(1, new ExceptionSet());
+        Clock<MaxInt> confC = vclock(4L, 0L);
 
         // [2, 0]
-        Clock<ExceptionSet> delivered = new Clock<>(nodeNumber, new ExceptionSet());
-        delivered.addDot(new Dot(0, 1L));
-        delivered.addDot(new Dot(0, 2L));
+        Clock<ExceptionSet> delivered = eclock(2L, 0L);
 
         List<QueueAddArgs> argsList = new ArrayList<>();
-        argsList.add(args(dotA, mapA));
-        argsList.add(args(dotB, mapB));
-        argsList.add(args(dotC, mapC));
+        argsList.add(args(dotA, confA));
+        argsList.add(args(dotB, confB));
+        argsList.add(args(dotC, confC));
 
         checkTerminationRandomShuffles(delivered, argsList);
     }
@@ -480,25 +399,13 @@ public class ConfQueueTest {
     }
 
     private QueueAddArgs args(Dot dot, Clock<MaxInt> conf) {
-        // create dep, given conf
-        return args(dot, conf, Clock.eclock(conf));
-    }
-
-    private QueueAddArgs args(Dot dot, HashMap<Integer, ExceptionSet> depMap) {
-        // create conf, given dep
-        HashMap<Integer, MaxInt> confMap = new HashMap<>();
-        for (Map.Entry<Integer, ExceptionSet> entry : depMap.entrySet()) {
-            confMap.put(entry.getKey(), entry.getValue().toMaxInt());
-        }
-        Clock<MaxInt> conf = new Clock<>(confMap);
-        Clock<ExceptionSet> dep = new Clock<>(depMap);
-        return args(dot, conf, dep);
-    }
-
-    private QueueAddArgs args(Dot dot, Clock<MaxInt> conf, Clock<ExceptionSet> dep) {
         // build random message
         Message message = Generator.message();
-        CommittedQueueBox box = new CommittedQueueBox(dot, dep, message, conf);
+        return args(dot, message, conf);
+    }
+
+    private QueueAddArgs args(Dot dot, Message message, Clock<MaxInt> conf) {
+        CommittedQueueBox box = new CommittedQueueBox(dot, null, message, conf);
         QueueAddArgs args = new QueueAddArgs(dot, conf, box);
         return args;
     }
@@ -534,4 +441,21 @@ public class ConfQueueTest {
         }
         return perColor;
     }
+
+    public Clock<MaxInt> vclock(Long... seqs) {
+        HashMap<Integer, MaxInt> map = new HashMap<>();
+        for (Integer i = 0; i < seqs.length; i++) {
+            map.put(i, new MaxInt(seqs[i]));
+        }
+        return new Clock<>(map);
+    }
+
+    public Clock<ExceptionSet> eclock(Long... seqs) {
+        HashMap<Integer, ExceptionSet> map = new HashMap<>();
+        for (Integer i = 0; i < seqs.length; i++) {
+            map.put(i, new ExceptionSet(seqs[i]));
+        }
+        return new Clock<>(map);
+    }
+
 }
