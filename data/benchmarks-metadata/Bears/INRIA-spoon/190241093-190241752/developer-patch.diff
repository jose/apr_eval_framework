diff --git a/src/main/java/spoon/reflect/factory/ExecutableFactory.java b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
index d06fe9a42..e4ea1ff86 100644
--- a/src/main/java/spoon/reflect/factory/ExecutableFactory.java
+++ b/src/main/java/spoon/reflect/factory/ExecutableFactory.java
@@ -114,6 +114,7 @@ public class ExecutableFactory extends SubFactory {
 		} else if (e instanceof CtAnonymousExecutable) {
 			return createReference(((CtAnonymousExecutable) e).getDeclaringType().getReference(), e.getType().clone(), executableName);
 		}
+		// constructor
 		return createReference(((CtConstructor<T>) e).getDeclaringType().getReference(), ((CtConstructor<T>) e).getType().clone(), CtExecutableReference.CONSTRUCTOR_NAME, refs);
 	}
 
diff --git a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
index 51bbfa304..f7fa778c0 100644
--- a/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
+++ b/src/main/java/spoon/support/compiler/jdt/ParentExiter.java
@@ -721,9 +721,7 @@ public class ParentExiter extends CtInheritanceScanner {
 	private <T> boolean hasChildEqualsToType(CtConstructorCall<T> ctConstructorCall) {
 		final AllocationExpression parent = (AllocationExpression) jdtTreeBuilder.getContextBuilder().stack.peek().node;
 		// Type is equals to the jdt child.
-		return parent.type != null && parent.type.equals(childJDT)
-				// Type not yet initialized.
-				&& !((CtTypeAccess) child).getAccessedType().equals(ctConstructorCall.getExecutable().getType());
+		return parent.type != null && parent.type.equals(childJDT);
 	}
 
 	@Override
diff --git a/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java b/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
index f873b1f94..a8c820834 100644
--- a/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
+++ b/src/main/java/spoon/support/compiler/jdt/ReferenceBuilder.java
@@ -338,11 +338,14 @@ public class ReferenceBuilder {
 		if (exec == null) {
 			return null;
 		}
-
 		final CtExecutableReference ref = this.jdtTreeBuilder.getFactory().Core().createExecutableReference();
-		ref.setSimpleName(new String(exec.selector));
-		ref.setType(getTypeReference(exec.returnType));
-
+		if (exec.isConstructor()) {
+			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);
+			ref.setType(getTypeReference(exec.declaringClass));
+		} else {
+			ref.setSimpleName(new String(exec.selector));
+			ref.setType(getTypeReference(exec.returnType));
+		}
 		if (exec instanceof ProblemMethodBinding) {
 			if (exec.declaringClass != null && Arrays.asList(exec.declaringClass.methods()).contains(exec)) {
 				ref.setDeclaringType(getTypeReference(exec.declaringClass));
diff --git a/src/test/java/spoon/test/reference/TypeReferenceTest.java b/src/test/java/spoon/test/reference/TypeReferenceTest.java
index 6fe4fe2b4..0bd731b99 100644
--- a/src/test/java/spoon/test/reference/TypeReferenceTest.java
+++ b/src/test/java/spoon/test/reference/TypeReferenceTest.java
@@ -2,7 +2,6 @@ package spoon.test.reference;
 
 import org.junit.Test;
 import spoon.Launcher;
-import spoon.SpoonException;
 import spoon.compiler.SpoonCompiler;
 import spoon.compiler.SpoonResource;
 import spoon.compiler.SpoonResourceHelper;
@@ -19,20 +18,23 @@ import spoon.reflect.declaration.CtEnum;
 import spoon.reflect.declaration.CtField;
 import spoon.reflect.declaration.CtInterface;
 import spoon.reflect.declaration.CtMethod;
+import spoon.reflect.declaration.CtParameter;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.declaration.CtTypeParameter;
 import spoon.reflect.factory.Factory;
 import spoon.reflect.reference.CtExecutableReference;
 import spoon.reflect.reference.CtFieldReference;
+import spoon.reflect.reference.CtParameterReference;
 import spoon.reflect.reference.CtTypeParameterReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.reference.CtWildcardReference;
 import spoon.reflect.visitor.Query;
+import spoon.reflect.visitor.filter.NameFilter;
 import spoon.reflect.visitor.filter.ReferenceTypeFilter;
 import spoon.reflect.visitor.filter.TypeFilter;
-import spoon.support.compiler.SnippetCompilationHelper;
 import spoon.test.reference.testclasses.EnumValue;
 import spoon.test.reference.testclasses.Panini;
+import spoon.test.reference.testclasses.ParamRefs;
 import spoon.testing.utils.ModelUtils;
 
 import java.util.ArrayList;
@@ -592,4 +594,17 @@ public class TypeReferenceTest {
 		assertEquals("String", s2.getType().getActualTypeArguments().get(0).getSimpleName());
 		assertEquals(String.class, s2.getType().getActualTypeArguments().get(0).getTypeDeclaration().getActualClass());
 	}
+
+	@Test
+	public void testEqualityTypeReference() throws Exception {
+		CtClass<ParamRefs> aClass = (CtClass) buildClass(ParamRefs.class);
+		CtParameter<?> parameter = aClass.getElements(new NameFilter<CtParameter<?>>("param")).get(0);
+		CtParameterReference<?> parameterRef1 = parameter.getReference();
+		CtParameterReference<?> parameterRef2 = aClass.getElements((CtParameterReference<?> ref)->ref.getSimpleName().equals("param")).get(0);
+
+		assertEquals(aClass.getReference(), parameterRef1.getDeclaringExecutable().getType());
+		assertEquals(aClass.getReference(), parameterRef2.getDeclaringExecutable().getType());
+
+		assertEquals(parameterRef1, parameterRef2);
+	}
 }
diff --git a/src/test/java/spoon/test/reference/testclasses/ParamRefs.java b/src/test/java/spoon/test/reference/testclasses/ParamRefs.java
new file mode 100644
index 000000000..cafb1a281
--- /dev/null
+++ b/src/test/java/spoon/test/reference/testclasses/ParamRefs.java
@@ -0,0 +1,7 @@
+package spoon.test.reference.testclasses;
+
+public class ParamRefs {
+	public ParamRefs(int param) {
+		if(param == 0){}
+	}
+}
\ No newline at end of file
