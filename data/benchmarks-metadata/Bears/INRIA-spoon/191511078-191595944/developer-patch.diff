diff --git a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
index 6a600a6e9..82a30e618 100644
--- a/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
+++ b/src/main/java/spoon/support/reflect/reference/CtTypeReferenceImpl.java
@@ -619,7 +619,7 @@ public class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeRef
 			}
 			if (modifiers.contains(ModifierKind.PRIVATE)) {
 				//it is visible in scope of the same class only
-				return type.getTopLevelType().getQualifiedName().equals(this.getQualifiedName());
+				return type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());
 			}
 			//package protected
 			if (type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())) {
@@ -674,6 +674,9 @@ public class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeRef
 			}
 			declType = visibleDeclType;
 		}
+		if (declType == null) {
+			throw new SpoonException("Cannot compute access path to type: " + this.getQualifiedName() + " in context of type: " + contextType.getQualifiedName());
+		}
 		return declType;
 	}
 
diff --git a/src/test/java/spoon/test/imports/ImportTest.java b/src/test/java/spoon/test/imports/ImportTest.java
index bd768a319..1a953240e 100644
--- a/src/test/java/spoon/test/imports/ImportTest.java
+++ b/src/test/java/spoon/test/imports/ImportTest.java
@@ -403,8 +403,11 @@ public class ImportTest {
 		}
 		CtClass<?> mm = launcher.getFactory().Class().get("spoon.test.imports.testclasses2.AbstractMapBasedMultimap");
 		CtClass<?> mmwli = launcher.getFactory().Class().get("spoon.test.imports.testclasses2.AbstractMapBasedMultimap$WrappedList$WrappedListIterator");
-		assertTrue(mmwli.toString().indexOf("AbstractMapBasedMultimap<K, V>.WrappedList.WrappedIterator")>=0);
-		assertTrue(mm.toString().indexOf("AbstractMapBasedMultimap<K, V>.WrappedList.WrappedIterator")>=0);
+		assertEquals("private class WrappedListIterator extends spoon.test.imports.testclasses2.AbstractMapBasedMultimap<K, V>.WrappedCollection.WrappedIterator {}",mmwli.toString());
+		assertTrue(mm.toString().indexOf("AbstractMapBasedMultimap<K, V>.WrappedCollection.WrappedIterator")>=0);
+
+		CtClass<?> mmwliother = launcher.getFactory().Class().get("spoon.test.imports.testclasses2.AbstractMapBasedMultimap$OtherWrappedList$WrappedListIterator");
+		assertEquals("private class WrappedListIterator extends spoon.test.imports.testclasses2.AbstractMapBasedMultimap<K, V>.OtherWrappedList.WrappedIterator {}",mmwliother.toString());
 		 								  
 	}
 
@@ -424,9 +427,12 @@ public class ImportTest {
 
 		CtClass<?> mm = launcher.getFactory().Class().get("spoon.test.imports.testclasses2.AbstractMapBasedMultimap");
 		CtClass<?> mmwli = launcher.getFactory().Class().get("spoon.test.imports.testclasses2.AbstractMapBasedMultimap$WrappedList$WrappedListIterator");
-		assertTrue(mmwli.toString().indexOf("AbstractMapBasedMultimap<K, V>.WrappedList.WrappedIterator")>=0);
-		assertTrue(mm.toString().indexOf("AbstractMapBasedMultimap<K, V>.WrappedList.WrappedIterator")>=0);
-		 								  
+		assertEquals("private class WrappedListIterator extends AbstractMapBasedMultimap<K, V>.WrappedCollection.WrappedIterator {}",mmwli.toString());
+		assertTrue(mm.toString().indexOf("AbstractMapBasedMultimap<K, V>.WrappedCollection.WrappedIterator")>=0);
+
+		CtClass<?> mmwliother = launcher.getFactory().Class().get("spoon.test.imports.testclasses2.AbstractMapBasedMultimap$OtherWrappedList$WrappedListIterator");
+		assertEquals("private class WrappedListIterator extends AbstractMapBasedMultimap<K, V>.OtherWrappedList.WrappedIterator {}",mmwliother.toString());
+
 	}
 
 	@Test
@@ -603,4 +609,25 @@ public class ImportTest {
 		assertTrue("The file should not contain a static import for NOFOLLOW_LINKS",!output.contains("import static java.nio.file.LinkOption.NOFOLLOW_LINKS;"));
 		canBeBuilt(outputDir, 7);
 	}
+	
+	@Test
+	public void testAccessPath() {
+		final Launcher launcher = new Launcher();
+		launcher.addInputResource("./src/test/java/spoon/test/imports/testclasses/TransportIndicesShardStoresAction.java");
+		String outputDir = "./target/spooned-accessPath";
+		launcher.setSourceOutputDirectory(outputDir);
+		launcher.run();
+		CtType element = launcher.getFactory().Class().getAll().get(0);
+		
+		PrettyPrinter prettyPrinter = launcher.createPrettyPrinter();
+
+		List<CtType<?>> toPrint = new ArrayList<>();
+		toPrint.add(element);
+
+		prettyPrinter.calculate(element.getPosition().getCompilationUnit(), toPrint);
+		String output = prettyPrinter.getResult();
+
+		canBeBuilt(outputDir, 7);
+	}
+	
 }
diff --git a/src/test/java/spoon/test/imports/testclasses/TransportIndicesShardStoresAction.java b/src/test/java/spoon/test/imports/testclasses/TransportIndicesShardStoresAction.java
new file mode 100644
index 000000000..bbc63a567
--- /dev/null
+++ b/src/test/java/spoon/test/imports/testclasses/TransportIndicesShardStoresAction.java
@@ -0,0 +1,17 @@
+package spoon.test.imports.testclasses;
+
+import java.util.Queue;
+
+public class TransportIndicesShardStoresAction {
+
+    private class AsyncShardStoresInfoFetches {
+    	
+        private Queue<InternalAsyncFetch.Response> fetchResponses;
+
+        private class InternalAsyncFetch {
+
+            public class Response {
+            }
+        }
+    }
+}
diff --git a/src/test/java/spoon/test/imports/testclasses2/AbstractMapBasedMultimap.java b/src/test/java/spoon/test/imports/testclasses2/AbstractMapBasedMultimap.java
index 98b519118..8b994b662 100644
--- a/src/test/java/spoon/test/imports/testclasses2/AbstractMapBasedMultimap.java
+++ b/src/test/java/spoon/test/imports/testclasses2/AbstractMapBasedMultimap.java
@@ -9,4 +9,13 @@ abstract class AbstractMapBasedMultimap<K, V> {
 		private class WrappedListIterator extends WrappedIterator {
 		}
 	}
+
+	private class OtherWrappedList extends WrappedCollection {
+		private class WrappedListIterator extends WrappedIterator {
+		}
+
+		class WrappedIterator {
+
+		}
+	}
 }
