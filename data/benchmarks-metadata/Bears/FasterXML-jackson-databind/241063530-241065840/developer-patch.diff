diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
index 21f37fe1c..12162c57f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
+++ b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
@@ -25,6 +25,14 @@ public class ResolvedRecursiveType extends TypeBase
         }
         _referencedType = ref;
     }
+   
+    @Override
+    public JavaType getSuperClass() {
+    	if (_referencedType != null) {
+    		return _referencedType.getSuperClass();
+    	}
+    	return super.getSuperClass();
+    }
 
     public JavaType getSelfReferencedType() { return _referencedType; }
 
diff --git a/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java b/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java
index 57115cf96..f0643afde 100644
--- a/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java
@@ -13,6 +13,15 @@ public class RecursiveTypeTest extends BaseMapTest
  // for [databind#938]
     public static interface Ability<T> { }
 
+    // for [databind#1647]
+    static interface IFace<T> {}
+
+    // for [databind#1647]
+    static class Base implements IFace<Sub> { }
+
+    // for [databind#1647]
+    static class Sub extends Base { }
+
     public static final class ImmutablePair<L, R> implements Map.Entry<L, R>, Ability<ImmutablePair<L, R>> {
         public final L key;
         public final R value;
@@ -93,4 +102,14 @@ public class RecursiveTypeTest extends BaseMapTest
             fail("Description should contain 'recursive type', did not: "+desc);
         }
     }
+
+    // for [databind#1647]
+    public void testSuperClassWithReferencedJavaType() {
+        TypeFactory tf = objectMapper().getTypeFactory();
+        tf.constructType(Base.class); // must be constructed before sub to set the cache correctly
+        JavaType subType = tf.constructType(Sub.class);
+        // baseTypeFromSub should be a ResolvedRecursiveType in this test
+        JavaType baseTypeFromSub = subType.getSuperClass();
+        assertNotNull(baseTypeFromSub.getSuperClass());
+    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java
new file mode 100644
index 000000000..50c524938
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java
@@ -0,0 +1,32 @@
+package com.fasterxml.jackson.databind.type;
+
+import java.io.IOException;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.BaseMapTest;
+import com.fasterxml.jackson.databind.type.TypeFactory;
+
+
+// https://github.com/FasterXML/jackson-databind/issues/1647
+public class TestTypeFactoryWithRecursiveTypes extends BaseMapTest {
+
+    static interface IFace<T> {
+    }
+
+    static class Base implements IFace<Sub> {
+        @JsonProperty int base = 1;
+    }
+
+    static class Sub extends Base {
+        @JsonProperty int sub = 2;
+    }
+
+    public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        tf.constructType(Base.class);
+        tf.constructType(Sub.class);
+        Sub sub = new Sub();
+        String serialized = objectMapper().writeValueAsString(sub);
+        assertEquals("{\"base\":1,\"sub\":2}", serialized);
+    }
+}
