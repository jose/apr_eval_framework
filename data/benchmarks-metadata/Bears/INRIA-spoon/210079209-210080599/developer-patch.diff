diff --git a/src/main/java/spoon/reflect/visitor/filter/PotentialVariableDeclarationFunction.java b/src/main/java/spoon/reflect/visitor/filter/PotentialVariableDeclarationFunction.java
index 12d93e40a..842b070d0 100644
--- a/src/main/java/spoon/reflect/visitor/filter/PotentialVariableDeclarationFunction.java
+++ b/src/main/java/spoon/reflect/visitor/filter/PotentialVariableDeclarationFunction.java
@@ -70,7 +70,7 @@ public class PotentialVariableDeclarationFunction implements CtConsumableFunctio
 
 		CtElement scopeElement = input;
 		//Search input and then all parents until first CtPackage for element which may represents the declaration of this local variable
-		while (scopeElement != null && !(scopeElement instanceof CtPackage)) {
+		while (scopeElement != null && !(scopeElement instanceof CtPackage) && scopeElement.isParentInitialized()) {
 			CtElement parent = scopeElement.getParent();
 			if (parent instanceof CtType<?>) {
 				if (includingFields) {
diff --git a/src/test/java/spoon/test/prettyprinter/QualifiedThisRefTest.java b/src/test/java/spoon/test/prettyprinter/QualifiedThisRefTest.java
index 7428a5cb6..90c052d83 100644
--- a/src/test/java/spoon/test/prettyprinter/QualifiedThisRefTest.java
+++ b/src/test/java/spoon/test/prettyprinter/QualifiedThisRefTest.java
@@ -1,11 +1,14 @@
 package spoon.test.prettyprinter;
 
+import org.apache.commons.lang3.StringEscapeUtils;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import spoon.Launcher;
 import spoon.compiler.SpoonResourceHelper;
+import spoon.reflect.code.CtExpression;
 import spoon.reflect.code.CtInvocation;
+import spoon.reflect.code.CtLiteral;
 import spoon.reflect.code.CtStatement;
 import spoon.reflect.code.CtThisAccess;
 import spoon.reflect.code.CtTypeAccess;
@@ -13,19 +16,25 @@ import spoon.reflect.declaration.CtClass;
 import spoon.reflect.declaration.CtMethod;
 import spoon.reflect.declaration.CtType;
 import spoon.reflect.factory.Factory;
+import spoon.reflect.reference.CtExecutableReference;
+import spoon.reflect.reference.CtFieldReference;
 import spoon.reflect.reference.CtReference;
 import spoon.reflect.reference.CtTypeReference;
 import spoon.reflect.visitor.DefaultJavaPrettyPrinter;
 import spoon.reflect.visitor.filter.TypeFilter;
+import spoon.support.reflect.code.CtFieldAccessImpl;
+import spoon.support.reflect.reference.CtFieldReferenceImpl;
 import spoon.test.delete.testclasses.Adobada;
 import spoon.test.prettyprinter.testclasses.QualifiedThisRef;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
 import static javax.swing.text.html.HTML.Tag.HEAD;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 import static spoon.testing.utils.ModelUtils.build;
@@ -81,4 +90,53 @@ public class QualifiedThisRefTest {
 		// it makes perfectly sense about the meaning of this.
 		// to "transplant" a this, you have to first set the target to null
 	}
+
+	@Test
+	public void testPrintCtFieldAccessWorkEvenWhenParentNotInitialized() throws Exception {
+		CtClass zeclass = factory.Class().get(QualifiedThisRef.class);
+
+		List<CtMethod> methods = zeclass.getMethodsByName("bla");
+
+		assertEquals(1, methods.size());
+
+		CtStatement invocation = methods.get(0).getBody().getStatement(0);
+
+		assertTrue(invocation instanceof CtInvocation);
+		CtInvocation<?> arg0 = (CtInvocation) invocation;
+
+		CtExpression param = arg0.getArguments().get(0);
+		CtExecutableReference execref = factory.Core().createExecutableReference();
+		execref.setDeclaringType(factory.Type().createReference("java.util.Map"));
+		execref.setSimpleName("exorcise");
+		execref.setStatic(true);
+
+		CtTypeReference tmp = param.getType();
+
+		CtExpression arg = null;
+		CtFieldReference ctfe = new CtFieldReferenceImpl();
+		ctfe.setSimpleName("class");
+		ctfe.setDeclaringType(tmp.box());
+		arg = factory.Core().createFieldRead();
+		((CtFieldAccessImpl) arg).setVariable(ctfe);
+
+
+		CtLiteral location = factory.Core().createLiteral();
+		location.setType(factory.Type().createReference(String.class));
+
+		CtTypeReference tmpref = factory.Core().clone(tmp);
+
+		CtInvocation invoc = factory.Core().createInvocation();
+		invoc.setExecutable(execref);
+		invoc.setArguments(Arrays.asList(new CtExpression[]{param,arg,location}));
+		execref.setActualTypeArguments(Arrays.asList(new CtTypeReference<?>[]{tmpref}));
+
+		// succeeds
+		arg0.getArguments().set(0, invoc);
+
+		DefaultJavaPrettyPrinter printer = new DefaultJavaPrettyPrinter(factory.getEnvironment());
+		printer.visitCtClass(zeclass);
+
+		assertFalse(printer.getResult().isEmpty());
+
+	}
 }
diff --git a/src/test/java/spoon/test/prettyprinter/testclasses/QualifiedThisRef.java b/src/test/java/spoon/test/prettyprinter/testclasses/QualifiedThisRef.java
index 2854350b3..74ac72460 100644
--- a/src/test/java/spoon/test/prettyprinter/testclasses/QualifiedThisRef.java
+++ b/src/test/java/spoon/test/prettyprinter/testclasses/QualifiedThisRef.java
@@ -2,6 +2,7 @@ package spoon.test.prettyprinter.testclasses;
 
 public class QualifiedThisRef<T> {
 
+	private Sub sub;
 	class Sub {
 		void foo() {
 			Object o = spoon.test.prettyprinter.testclasses.QualifiedThisRef.Sub.this;
@@ -10,4 +11,6 @@ public class QualifiedThisRef<T> {
 			Object o2 = spoon.test.prettyprinter.testclasses.QualifiedThisRef.this;
 		}
 	}
+
+	void bla() { System.out.println(sub); }
 }
