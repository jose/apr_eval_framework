diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
index 651b62d23..9cb8bec18 100644
--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
@@ -1,5 +1,6 @@
 package com.fasterxml.jackson.databind.jsontype.impl;
 
+import java.lang.reflect.Modifier;
 import java.util.*;
 
 import com.fasterxml.jackson.databind.AnnotationIntrospector;
@@ -21,7 +22,7 @@ public class StdSubtypeResolver
     protected LinkedHashSet<NamedType> _registeredSubtypes;
 
     public StdSubtypeResolver() { }
-    
+
     /*
     /**********************************************************
     /* Subtype registration
@@ -75,15 +76,17 @@ public class StdSubtypeResolver
         }
         
         // then annotated types for property itself
-        Collection<NamedType> st = ai.findSubtypes(property);
-        if (st != null) {
-            for (NamedType nt : st) {
-                AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
-                        nt.getType());
-                _collectAndResolve(ac, nt, config, ai, collected);
-            }            
+        if (property != null) {
+            Collection<NamedType> st = ai.findSubtypes(property);
+            if (st != null) {
+                for (NamedType nt : st) {
+                    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
+                            nt.getType());
+                    _collectAndResolve(ac, nt, config, ai, collected);
+                }            
+            }
         }
-        
+
         NamedType rootType = new NamedType(rawBase, null);
         AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);
             
@@ -128,7 +131,7 @@ public class StdSubtypeResolver
             AnnotatedMember property, JavaType baseType)
     {
         final AnnotationIntrospector ai = config.getAnnotationIntrospector();
-        Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();
+        Class<?> rawBase = baseType.getRawClass();
 
         // Need to keep track of classes that have been handled already 
         Set<Class<?>> typesHandled = new HashSet<Class<?>>();
@@ -141,14 +144,15 @@ public class StdSubtypeResolver
         _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);
         
         // then with definitions from property
-        Collection<NamedType> st = ai.findSubtypes(property);
-        if (st != null) {
-            for (NamedType nt : st) {
-                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());
-                _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);
-            }            
+        if (property != null) {
+            Collection<NamedType> st = ai.findSubtypes(property);
+            if (st != null) {
+                for (NamedType nt : st) {
+                    ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());
+                    _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);
+                }            
+            }
         }
-        
         // and finally explicit type registrations (highest precedence)
         if (_registeredSubtypes != null) {
             for (NamedType subtype : _registeredSubtypes) {
@@ -160,21 +164,21 @@ public class StdSubtypeResolver
                 }
             }
         }
-        return _combineNamedAndUnnamed(typesHandled, byName);
+        return _combineNamedAndUnnamed(rawBase, typesHandled, byName);
     }
 
     @Override
     public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config,
-            AnnotatedClass type)
+            AnnotatedClass baseType)
     {
+        final Class<?> rawBase = baseType.getRawType();
         Set<Class<?>> typesHandled = new HashSet<Class<?>>();
         Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();
 
-        NamedType rootType = new NamedType(type.getRawType(), null);
-        _collectAndResolveByTypeId(type, rootType, config, typesHandled, byName);
+        NamedType rootType = new NamedType(rawBase, null);
+        _collectAndResolveByTypeId(baseType, rootType, config, typesHandled, byName);
         
         if (_registeredSubtypes != null) {
-            Class<?> rawBase = type.getRawType();
             for (NamedType subtype : _registeredSubtypes) {
                 // is it a subtype of root type?
                 if (rawBase.isAssignableFrom(subtype.getType())) { // yes
@@ -184,7 +188,7 @@ public class StdSubtypeResolver
                 }
             }
         }
-        return _combineNamedAndUnnamed(typesHandled, byName);
+        return _combineNamedAndUnnamed(rawBase, typesHandled, byName);
     }
 
     /*
@@ -267,8 +271,8 @@ public class StdSubtypeResolver
      * Helper method used for merging explicitly named types and handled classes
      * without explicit names.
      */
-    protected Collection<NamedType> _combineNamedAndUnnamed(Set<Class<?>> typesHandled,
-            Map<String,NamedType> byName)
+    protected Collection<NamedType> _combineNamedAndUnnamed(Class<?> rawBase,
+            Set<Class<?>> typesHandled, Map<String,NamedType> byName)
     {
         ArrayList<NamedType> result = new ArrayList<NamedType>(byName.values());
 
@@ -279,6 +283,11 @@ public class StdSubtypeResolver
             typesHandled.remove(t.getType());
         }
         for (Class<?> cls : typesHandled) {
+            // 27-Apr-2017, tatu: [databind#1616] Do not add base type itself unless
+            //     it is concrete (or has explicit type name)
+            if ((cls == rawBase) && Modifier.isAbstract(cls.getModifiers())) {
+                continue;
+            }
             result.add(new NamedType(cls));
         }
         return result;
diff --git a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
index 77518db30..4771d790f 100644
--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java
@@ -291,13 +291,13 @@ public abstract class BaseMapTest
     protected String serializeAsString(Object value)
         throws IOException
     {
-        return serializeAsString(SHARED_MAPPER, value);
+        return serializeAsString(objectMapper(), value);
     }
 
     protected String asJSONObjectValueString(Object... args)
         throws IOException
     {
-        return asJSONObjectValueString(SHARED_MAPPER, args);
+        return asJSONObjectValueString(objectMapper(), args);
     }
 
     protected String asJSONObjectValueString(ObjectMapper m, Object... args)
@@ -319,7 +319,7 @@ public abstract class BaseMapTest
     protected <T> T readAndMapFromString(String input, Class<T> cls)
         throws IOException
     {
-        return readAndMapFromString(SHARED_MAPPER, input, cls);
+        return readAndMapFromString(objectMapper(), input, cls);
     }
 
     protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls) throws IOException
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForMaps.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForMaps.java
index c36ebd26a..aa5ada478 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForMaps.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForMaps.java
@@ -118,8 +118,6 @@ public class TestDefaultForMaps
                 TypeFactory.defaultInstance().constructType(Object.class), subtypes, forSerialization, !forSerialization);
     }
 
-    // // For #234:
-    
     public void testList() throws Exception
     {
         final ObjectMapper mapper = new ObjectMapper();
diff --git a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypeNames.java b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypeNames.java
index cfe6a6b8b..735b22d3c 100644
--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypeNames.java
+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypeNames.java
@@ -7,19 +7,31 @@ import com.fasterxml.jackson.annotation.*;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
 import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
+
 import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;
 import com.fasterxml.jackson.databind.type.TypeFactory;
 
 /**
  * Separate tests for verifying that "type name" type id mechanism
  * works.
- * 
- * @author tatu
  */
 public class TestTypeNames extends BaseMapTest
 {
     @SuppressWarnings("serial")
     static class AnimalMap extends LinkedHashMap<String,Animal> { }
+
+    @JsonTypeInfo(property = "type", include = JsonTypeInfo.As.PROPERTY, use = JsonTypeInfo.Id.NAME)
+    @JsonSubTypes({
+              @JsonSubTypes.Type(value = A1616.class,name = "A"),
+              @JsonSubTypes.Type(value = B1616.class)
+    })
+    static abstract class Base1616 { }
+
+    static class A1616 extends Base1616 { }
+
+    @JsonTypeName("B")
+    static class B1616 extends Base1616 { }
     
     /*
     /**********************************************************
@@ -27,31 +39,48 @@ public class TestTypeNames extends BaseMapTest
     /**********************************************************
      */
 
+    private final ObjectMapper MAPPER = objectMapper();
+
+    public void testBaseTypeId1616() throws Exception
+    {
+        ObjectMapper mapper = new ObjectMapper();
+        Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(
+                mapper.getDeserializationConfig(),
+                // note: `null` is fine here as `AnnotatedMember`:
+                null,
+                mapper.constructType(Base1616.class));
+        assertEquals(2, subtypes.size());
+        Set<String> ok = new HashSet<>(Arrays.asList("A", "B"));
+        for (NamedType type : subtypes) {
+            String id = type.getName();
+            if (!ok.contains(id)) {
+                fail("Unexpected id '"+id+"' (mapping to: "+type.getType()+"), should be one of: "+ok);
+            }
+        }
+    }
+    
     public void testSerialization() throws Exception
     {
-        ObjectMapper m = new ObjectMapper();
-
         // Note: need to use wrapper array just so that we can define
         // static type on serialization. If we had root static types,
         // could use those; but at the moment root type is dynamic
         
         assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]",
-                m.writeValueAsString(new Animal[] { new Dog("Spot", 3) }));
+                MAPPER.writeValueAsString(new Animal[] { new Dog("Spot", 3) }));
         assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]",
-                m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true)}));
+                MAPPER.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true)}));
     }
 
     public void testRoundTrip() throws Exception
     {
-        ObjectMapper m = new ObjectMapper();
         Animal[] input = new Animal[] {
                 new Dog("Odie", 7),
                 null,
                 new MaineCoon("Piru", false),
                 new Persian("Khomeini", true)
         };
-        String json = m.writeValueAsString(input);
-        List<Animal> output = m.readValue(json,
+        String json = MAPPER.writeValueAsString(input);
+        List<Animal> output = MAPPER.readValue(json,
                 TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class));
         assertEquals(input.length, output.size());
         for (int i = 0, len = input.length; i < len; ++i) {
@@ -62,12 +91,11 @@ public class TestTypeNames extends BaseMapTest
 
     public void testRoundTripMap() throws Exception
     {
-        ObjectMapper m = new ObjectMapper();
         AnimalMap input = new AnimalMap();
         input.put("venla", new MaineCoon("Venla", true));
         input.put("ama", new Dog("Amadeus", 13));
-        String json = m.writeValueAsString(input);
-        AnimalMap output = m.readValue(json, AnimalMap.class);
+        String json = MAPPER.writeValueAsString(input);
+        AnimalMap output = MAPPER.readValue(json, AnimalMap.class);
         assertNotNull(output);
         assertEquals(AnimalMap.class, output.getClass());
         assertEquals(input.size(), output.size());
