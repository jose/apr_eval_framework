diff --git a/src/main/java/spoon/support/visitor/ClassTypingContext.java b/src/main/java/spoon/support/visitor/ClassTypingContext.java
index ba9f1cc53..8147a59e9 100644
--- a/src/main/java/spoon/support/visitor/ClassTypingContext.java
+++ b/src/main/java/spoon/support/visitor/ClassTypingContext.java
@@ -373,7 +373,7 @@ public class ClassTypingContext implements GenericTypeAdapter {
 					throw new SpoonException("Cannot adapt type parameters of non type scope");
 				}
 				CtType<?> typeDeclarer = (CtType<?>) declarer;
-				List<CtTypeReference<?>> actualTypeArguments = typeToArguments.get(typeDeclarer.getQualifiedName());
+				List<CtTypeReference<?>> actualTypeArguments = getActualTypeArguments(typeDeclarer.getQualifiedName());
 				if (actualTypeArguments == null) {
 					/*
 					 * the actualTypeArguments of this declarer cannot be resolved.
@@ -399,6 +399,17 @@ public class ClassTypingContext implements GenericTypeAdapter {
 		return result;
 	}
 
+	private List<CtTypeReference<?>> getActualTypeArguments(String qualifiedName) {
+		List<CtTypeReference<?>> actualTypeArguments = typeToArguments.get(qualifiedName);
+		if (actualTypeArguments != null) {
+			return actualTypeArguments;
+		}
+		if (enclosingClassTypingContext != null) {
+			return enclosingClassTypingContext.getActualTypeArguments(qualifiedName);
+		}
+		return null;
+	}
+
 	private static CtTypeReference<?> getValue(List<CtTypeReference<?>> arguments, CtTypeParameter typeParam, CtFormalTypeDeclarer declarer) {
 		if (declarer.getFormalCtTypeParameters().size() != arguments.size()) {
 			throw new SpoonException("Unexpected count of actual type arguments");
diff --git a/src/test/java/spoon/test/generics/GenericsTest.java b/src/test/java/spoon/test/generics/GenericsTest.java
index 1ddc7e915..2126c3b3f 100644
--- a/src/test/java/spoon/test/generics/GenericsTest.java
+++ b/src/test/java/spoon/test/generics/GenericsTest.java
@@ -39,6 +39,7 @@ import spoon.support.visitor.ClassTypingContext;
 import spoon.support.visitor.GenericTypeAdapter;
 import spoon.support.visitor.MethodTypingContext;
 import spoon.test.ctType.testclasses.ErasureModelA;
+import spoon.test.generics.testclasses.Banana;
 import spoon.test.generics.testclasses.CelebrationLunch;
 import spoon.test.generics.testclasses.CelebrationLunch.WeddingLunch;
 import spoon.test.generics.testclasses.Lunch;
@@ -822,4 +823,13 @@ public class GenericsTest {
 		assertEquals("java.lang.Long", celebrationLunchTC.adaptType(classCelebrationLunch_L).getQualifiedName());
 		assertEquals("java.lang.Double", celebrationLunchTC.adaptType(classCelebrationLunch_M).getQualifiedName());
 	}
+	
+	@Test
+	public void testClassContextOnInnerClass() throws Exception {
+		CtClass<?> classBanana = (CtClass<?>)buildClass(Banana.class);
+		CtClass<?> classVitamins = classBanana.getNestedType("Vitamins");
+		CtTypeReference<?> refList_T = classVitamins.getSuperclass();
+		//contract: generic types defined in enclocing classe (Banana<T>) are resolved from inner class hierarchy (Vitamins->List<T>) too.
+		assertSame(classBanana.getFormalCtTypeParameters().get(0), new ClassTypingContext(classVitamins).adaptType(refList_T.getActualTypeArguments().get(0)).getDeclaration());
+	}
 }
diff --git a/src/test/java/spoon/test/generics/testclasses/Banana.java b/src/test/java/spoon/test/generics/testclasses/Banana.java
new file mode 100644
index 000000000..b45f33df2
--- /dev/null
+++ b/src/test/java/spoon/test/generics/testclasses/Banana.java
@@ -0,0 +1,8 @@
+package spoon.test.generics.testclasses;
+
+import java.util.AbstractList;
+
+public class Banana<T> {
+	abstract class Vitamins extends AbstractList<T> {
+	}
+}
